\documentclass[a4paper, 12pt, titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage[final]{pdfpages}
\usepackage[frenchb]{babel}%Pas important
\newcommand{\arc}[2]{$(#1~\rightarrow~#2)$}

\begin{document}
\input{titlepage}
\input{introduction}

\section{Répartition des tâches}
\noindent Guillaume \textsc{Huysmans} s'est chargé de:
\begin{itemize}
 \item Chargement d'un fichier FASTA
 \item Consensus et contig final à partir d'un chemin hamiltonien
 \item Parsing de la ligne de commande
 \item Écriture et chargement de chemin hamiltonien
 \item Sauvegarde du chemin hamiltonien (aide au débogage)
\end{itemize}
\noindent Tandis que Jason \textsc{Bury} s'est chargé de:
\begin{itemize}
 \item Création de tous les arcs et leur poids
 \item Algorithme Greedy et chemin hamiltonien
 \item Écriture d'un fichier FASTA
\end{itemize}

\section{Démarche}
Notre programme fonctionne en 5 étapes:
\begin{enumerate}
 \item Chargement des fragments
 \item Création des arcs
 \item Algorithme glouton
 \item Consensus
 \item Écriture du contig final
\end{enumerate}

\subsection{Création des arcs}
Après avoir chargé les fragments et leur complémentaire inversé,
il faut créer tous les arcs avant de les donner à l'algorithme Greedy.
Les arcs seront orientés :
\begin{itemize}
	\item soit l'alignement aligne le suffixe de $f$ avec le préfixe de $g$,
	\item soit l'alignement inclut $f$ dans $g$
\end{itemize}

Pour obtenir le poids d'un arc \arc{f}{g},
on calcule d'abord la matrice d'alignement semi-globale entre $f$ et $g$
où chaque ligne correspond à un symbole de $f$.
Le score est le maximum des scores de la dernière ligne.
En réalité, il n'est pas nécessaire de calculer
toutes les matrices d'alignement : on peut obtenir 4 scores par matrice,
c'est détaillé à la section \ref{sec:1m4s}.
Tout le travail est réparti sur 4 threads (voir section \ref{multithreading}).

\subsection{Les complémentaires inversés dans l'algorithme glouton}%explique comment on gère la suppressions des complémentaires inversés
Au cours de l'exécution de l'algorithme glouton (Greedy), lorsqu'un arc est ajouté au chemin hamiltonien, les complémentaires inversés de ses extrémités ne doivent plus être pris en compte.
Pour cela, nous avons modifié l'algorithme glouton et ajouté une fonction dans la structure union-find:
en ajoutant un arc \arc{f}{g} au chemin hamiltonien, nous mettons les booléens \texttt{in} et \texttt{out} de leur complémentaire inversé à vrai.
Ainsi les arcs issus de ces noeuds ne seront jamais ajoutés dans le chemin.
De plus, nous avons ajouté une méthode dans l'objet \texttt{UnionFind} afin de décrémenter le compteur d'ensembles distincts dans la structure.
Cette méthode sera appelée deux fois, chaque fois qu'un arc \arc{f}{g} est ajouté au chemin.
En effet, si l'arc \arc{f}{g} est ajouté au chemin, nous savons que la structure \texttt{UnionFind} contient les ensembles \{$\bar{f}$\} et \{$\bar{g}$\} puisqu'ils n'ont jamais fusionné avec un autre ensemble.
Puisqu'ils ne seront plus jamais utilisés, il n'est pas nécessaire de
réellement les supprimer, il suffit de décrémenter de deux le nombre d'ensembles distincts.
Ce compteur d'ensembles distincts est utilisé pour arrêter l'algorithme
lorsqu'il n'y a plus qu'un ensemble dans l'\texttt{UnionFind}.

\input{consensus}

\input{optimisation}

\section{Points forts et points faibles}
\subsection*{Points faibles}
Il reste des optimisations à faire pour l'algorithme de consensus et pour les tris des très nombreux arcs avant l'application de l'algorithme glouton.
Néanmoins, ces optimisations n'apporteraient que des gains négligeables par rapport au temps mis pour la création des arcs.

La mémoire utilisée est assez conséquente (3,5 Go).
Cela peut s'expliquer par le fait que les matrices d'alignement utilisées lors
de la création des arcs ne sont pas supprimées dès qu'elles ne sont plus
utilisées, le Garbage Collector de Java n'étant pas invoqué à la fin de chaque calcul de score.

Les résultats peuvent être différents d'une exécution à l'autre :
lors de la création des arcs, chaque thread crée et ajoute les arcs
dans une liste commune, sans aucune synchronisation.
Les threads n'étant pas réveillés dans le même ordre à chaque exécution,
l'algorithme devient non déterministe : après le tri des arcs
au début de l'algorithme glouton, ceux de même poids ne seront pas
toujours dans le même ordre d'une exécution à l'autre.

\subsection*{Points forts}
\begin{itemize}
	\item Rapidité : pour la collection 2 contenant 1600 fragments,
le temps d'exécution sur le PC distant mis à notre disposition est de 17 minutes.
Ce PC dispose de 64 CPUs x86-64 à 2,2 Ghz mais seuls 12 threads
ont été utilisés par notre programme.
	\item Séparation interface/calculs : le code est réutilisable, l'interface
en ligne de commande est séparée des vrais algorithmes au coeur du logiciel.
\end{itemize}

\section{Conclusion}
\subsection{Difficultés rencontrées}
La plus grande difficulté que nous avons rencontrée était l'élaboration de
l'algorithme de consensus.
D'abord, il a fallu trouver un moyen de propager les gaps :
lorsqu'un alignement entre deux fragments produit des gaps, il faut
les prendre en compte pour la position du prochain alignement dans le contig.

Ensuite, il fallait prendre en compte les inclusions de fragments.
Nous ne pouvions donc pas nous permettre de faire un consensus
jusqu'au début du prochain alignement.
En effet, si le prochain alignement inclut un fragment dans un autre, il risque
de dépasser à gauche de la position où se trouve le dernier symbole du
consensus réalisé jusque là.

Ensuite, nous avons été fort perturbés par l'utilisation que nous avons faite
de dotmatcher : en ligne et hors-ligne, les résultats étaient différents.
\end{document}
