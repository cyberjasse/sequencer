\documentclass[a4paper, 12pt, titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage[final]{pdfpages}
\usepackage[frenchb]{babel}%Pas important
\newcommand{\arc}[2]{$(#1~\rightarrow~#2)$}

\begin{document}
\input{titlepage}
\input{introduction}

\section{Répartition des tâches}
\noindent Guillaume \textsc{Huysmans} s'est chargé de:
\begin{itemize}
 \item Chargement d'un fichier fasta
 \item Consensus et contig final à partir d'un chemin hamiltonien
 \item Parsing de la ligne de commande
 \item Écriture et chargement de chemin hamiltonien
\end{itemize}
\noindent Tandis que Jason \textsc{Bury} s'est chargé de:
\begin{itemize}
 \item Création de tous les arcs et leur poids
 \item Algorithme Greedy et chemin hamiltonien
 \item Écriture d'un fichier fasta
\end{itemize}

\section{Démarche}
Notre programme fonctionne en 5 étapes:
\begin{enumerate}
 \item Chargement des fragments
 \item Création des arcs
 \item Algorithme glouton
 \item Consensus
 \item Écriture du contig final
\end{enumerate}

\subsection{Création des arcs}
Après avoir chargés les fragments et leur complémentaires inversés, il faut créer tous les arcs avant de passer à l'algorithme Greedy.
Les arcs seront orientés. Le sens d'un arc de $f$ à $g$ signifie que\\
soit l'alignement aligne le suffixe de $f$ avec le préfixe de $g$,\\
soit l'alignement inclu $f$ dans $g$.\\
Pour obtenir le poid d'un arc \arc{f}{g},
on calcul d'abord la matrice d'alignement semi-global entre $f$ et $g$ où chaque ligne correspond à un symbole de $f$.
Le score est le maximum des scores de la dernière ligne.
En réalité il n'est pas nécessaire de calculer toutes les matrices d'alignement car on peut obtenir 4 score par matrice (voir section \ref{sec:1m4s}).
Et tout le travail est réparti sur 4 threads (voir section \ref{multithreading}).

\subsection{Les complémentaires inversés dans l'algorithme glouton}%explique comment on gère la suppressions des complémentaires inversés
Au cours de l'exécution de l'algorithme glouton (Greedy), lorsqu'un arc est ajouté au chemin hamiltonien, les complémentaires inversés de ses noeuds ne doivent plus être pris en compte.
Pour cela, nous avons modifié l'algorithme glouton et ajouté une fonction dans la structure union-find:
en ajoutant un arc \arc{f}{g} au chemin hamiltonien, nous mettons les booléens \texttt{in} et \texttt{out} de leur complémentaire inversé à vrai.
Ainsi les arcs issus de ces noeuds ne seront jamais ajoutés dans le chemin.
De plus, nous avons ajouté une méthode dans l'objet \texttt{UnionFind} afin de décrémenter le compteur d'ensembles distincts dans la structure.
Cette méthode sera appelée deux fois : chaque fois qu'un arc \arc{f}{g} est ajouté au chemin.
En effet, si l'arc \arc{f}{g} est ajouté au chemin, nous savons que la structure \texttt{UnionFind} contient les ensembles \{$\bar{f}$\} et \{$\bar{g}$\} puisqu'ils n'ont jamais fusionné avec un autre ensemble.
Puisqu'ils ne seront plus jamais utilisés, il n'est pas nécessaire de
réellement les supprimer, il suffit de décrémenter de deux le nombre d'ensembles distincts.
Ce compteur d'ensembles distincts est utilisé pour arrêter l'algorithme
lorsqu'il n'y a plus qu'un ensemble dans l'\texttt{UnionFind}.

\input{consensus}

\input{optimisation}

\section{Points forts et points faibles}
\subsection*{Points faibles}
Il reste des optimisations à faire pour l'algorithme de consensus et pour les tris des très nombreux arcs avant l'application de l'algorithme glouton.
Mais ces optimisations apporteront des performances négligeables par rapport au temps mis pour la création des arcs.\\

La mémoire utilisée est assez volumineuse (3,5 Go).
Cela peut s'expliquer par le fait que les matrices d'alignement utilisées lors de la création des arcs ne sont pas supprimées dès qu'elles ne sont plus utilisées.
Le garbage collector n'étant pas invoqué à la fin de chaque calcul de score.

\subsection*{Points forts}
La rapidité de notre programme. En effet, pour la collection 2, contenant 1600 fragments,
Le temps d'exécution sur le PC distant mis à notre disposition est de 17 minutes.
Ce PC dispose de 64 CPUs x86-64 à 2,2Ghz mais 12 threads ont été utilisés par notre programme.

\end{document}
