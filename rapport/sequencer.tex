\documentclass[a4paper, 12pt, titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage[final]{pdfpages}
\usepackage[frenchb]{babel}%Pas important
\newcommand{\arc}[2]{$(#1~\rightarrow~#2)$}

\begin{document}
\input{titlepage}
\input{introduction}

\section{Répartition des tâches}
\noindent Guillaume \textsc{Huysmans} s'est chargé de:
\begin{itemize}
 \item Chargement d'un fichier fasta
 \item Consensus et contig final à partir d'un chemin hamiltonien
 \item Parsing de la ligne de commande
 \item Écriture et chargement de chemin hamiltonien
\end{itemize}
\noindent Tandis que Jason \textsc{Bury} s'est chargé de:
\begin{itemize}
 \item Création de tous les arcs et leur poids
 \item Algorithme Greedy et chemin hamiltonien
 \item Écriture d'un fichier fasta
\end{itemize}

\section{Démarche}
Notre programme fonctionne en 5 étapes:
\begin{enumerate}
 \item Chargement des fragments
 \item Création des arcs
 \item Algorithme glouton
 \item Consensus
 \item Écriture du contig final
\end{enumerate}

\subsection{Création des arcs}
Après avoir chargés les fragments et leur complémentaires inversés, il faut créer tous les arcs avant de passer à l'algorithme Greedy.
Les arcs seront orientés. Le sens d'un arc de $f$ à $g$ signifie que\\
soit l'alignement aligne le suffixe de $f$ avec le préfixe de $g$,\\
soit l'alignement inclu $f$ dans $g$.\\
Pour obtenir le poid d'un arc \arc{f}{g},
on calcul d'abord la matrice d'alignement semi-global entre $f$ et $g$ où chaque ligne correspond à un symbole de $f$.
Le score est le maximum des scores de la dernière ligne.
En réalité il n'est pas nécessaire de calculer toutes les matrices d'alignement car on peut obtenir 4 score par matrice (voir section \ref{sec:1m4s}).
Et tout le travail est réparti sur plusieurs threads (voir section \ref{multithreading}).

\subsection{Les complémentaires inversés dans l'algorithme glouton}%explique comment on gère la suppressions des complémentaires inversés
Au cours de l'exécution de l'algorithme glouton (Greedy), lorsqu'un arc est ajouté au chemin hamiltonien, les complémentaires inversés de ses noeuds ne doivent plus être pris en compte.
Pour cela, nous avons modifié l'algorithme glouton et ajouté une fonction dans la structure union-find:
en ajoutant un arc \arc{f}{g} au chemin hamiltonien, nous mettons les booléens \texttt{in} et \texttt{out} de leur complémentaire inversé à vrai.
Ainsi les arcs issus de ces noeuds ne seront jamais ajoutés dans le chemin.
De plus, nous avons ajouté une méthode dans l'objet \texttt{UnionFind} afin de décrémenter le compteur d'ensembles distincts dans la structure.
Cette méthode sera appelée deux fois : chaque fois qu'un arc \arc{f}{g} est ajouté au chemin.
En effet, si l'arc \arc{f}{g} est ajouté au chemin, nous savons que la structure \texttt{UnionFind} contient les ensembles \{$\bar{f}$\} et \{$\bar{g}$\} puisqu'ils n'ont jamais fusionné avec un autre ensemble.
Puisqu'ils ne seront plus jamais utilisés, il n'est pas nécessaire de
réellement les supprimer, il suffit de décrémenter de deux le nombre d'ensembles distincts.
Ce compteur d'ensembles distincts est utilisé pour arrêter l'algorithme
lorsqu'il n'y a plus qu'un ensemble dans l'\texttt{UnionFind}.

\input{consensus}

\input{optimisation}

\section{Points forts et points faibles}
\subsection*{Points faibles}
Il reste des optimisations à faire pour l'algorithme de consensus et pour les tris des très nombreux arcs avant l'application de l'algorithme glouton.
Mais ces optimisations apporteront des performances négligeables par rapport au temps mis pour la création des arcs.\\

La mémoire utilisée est assez volumineuse (3,5 Go).
Cela peut s'expliquer par le fait que les matrices d'alignement utilisées lors de la création des arcs ne sont pas supprimées dès qu'elles ne sont plus utilisées.
Le garbage collector n'étant pas invoqué à la fin de chaque calcul de score.\\

\subsection*{Points forts}
La rapidité de notre programme. En effet, pour la collection 2, contenant 1600 fragments,
Le temps d'exécution sur le PC distant mis à notre disposition est de 17 minutes.
Ce PC dispose de 64 CPUs x86-64 à 2,2Ghz mais 12 threads ont été utilisés par notre programme.\\

Une fonctionnalité bonus a été implémentée: il est possible de sauvegarder un chemin hamiltonien.
Cela permet de tester différentes méthodes de consensus sans devoir recalculer tous les arcs.

\newcommand{\dmscale}{0.6}
\newcommand{\incl}[2]{
\begin{figure}
 \begin{minipage}[c]{.47\linewidth}
  \includegraphics[scale=#2]{figures/dotmatcherc#1.png}
 \end{minipage}
 \begin{minipage}[c]{.47\linewidth}
  \includegraphics[scale=#2]{figures/dotmatcherc#1r.png}
 \end{minipage} 
 \caption{Résultat de la collection #1}
 \label{dm#1}
\end{figure}
}
\section{Observations}
Les Figures \ref{dm1}, \ref{dm2}, \ref{dm4} et \ref{dm5} ont été générées pas \emph{dotmatcher}.
L'image de droite représente le résultat du complémentaire inversé du contig produit par notre programme.\\
\incl{1}{\dmscale}
\begin{figure}
 \centering
 \includegraphics[scale=0.4]{figures/dotmatcherc2.png}
 \caption{Résultat de la collection 2}
 \label{dm2}
\end{figure}
\incl{4}{\dmscale}
\incl{5}{\dmscale}
La Figure \ref{dm2} est le meilleur résultat obtenu pour la collection 2 mais nous n'avons plus pu la reproduire.
On observe que nous produisons des contigs visiblement trop longs par rapport à la cible.
La cible est reproduite mais fragmentée en quelques morceaux et certains morceaux sont inversés complémentarisés.

\section{Conclusion}
\subsection{Difficultés rencontrées}
La plus grande difficulté que nous avons recontré était l'élaborration de l'algorithme de consensus.
D'abord il a fallut trouver un moyen de propager les gaps.
C'est à dire que lorsqu'un alignement entre deux fragments produit des gaps, il faut les prendre en compte pour la position du prochain alignement dans le contig.

Ensuite, il fallait prendre en compte les inclusions de fragments.
Nous ne pouvions donc pas nous permettre de faire un consensus jusque le début du prochain alignement.
En effet, si le prochain alignement s'agit d'un alignement qui va inclure un fragment dans un autre, cet alignement risque de dépasser vers la gauche la position où se trouve le dernier symbole du consensus.\\

Ensuite, nous avons été fort perturbés par l'utilisation que nous avons fait de dotmatcher. Dotmatcher en ligne nous affichait des résultats différents de dotmatcher hors-ligne.
Nous n'avons pas pu reproduire le résultats reporté ici pour la collection 2.
\end{document}
